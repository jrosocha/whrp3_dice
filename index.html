<!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01 Transitional//EN http://www.w3.org/TR/html4/loose.dtd>
<html>
<head>
	<META HTTP-EQUIV=pragma CONTENT=no-cache>
	<META HTTP-EQUIV=Expires CONTENT=-1>
	<META HTTP-EQUIV=Content-Type content=text/html; charset=ISO-8859-1>
	<title>WHRP3 Dice</title>
	<style type=text/css>
	      body { font-family: Arial, MS Trebuchet, sans-serif; font-size: 10px;}
	      table { font-family: Arial, MS Trebuchet, sans-serif; font-size: 10px;}
	      .arrayTable { border: 1px dashed #999; background-color: #DDD; padding: 5px;}
	      .arrayTr { border: 1px dashed #999; background-color: #DDD; padding: 5px;}
	      .arrayTd { border: 1px dashed #999; background-color: #DDD; padding: 5px; vertical-align: top;}
	      .associativeTable { border: 8px solid #999; background-color: #999; padding: 1px;}
	      .associativeTr { border: 1px solid #999; background-color: #AAA; padding: 5px;}
	      .associativeTd { border: 1px solid #999; background-color: #AAA; padding: 5px; vertical-align: top;}
	</style>
	
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
	<script type="text/javascript" src="https://www.google.com/jsapi"></script>

</head>

<div id="inputDiv">

	<label># of Fortune Dice</label> 
	<input id="inputFortune" type="text" />

	<label># of Characteristic Dice</label> 
	<input id="inputCharacteristic" type="text" />

	<label># of Reckless Dice</label> 
	<input id="inputReckless" type="text" />	

	<label># of Conservative Dice</label> 
	<input id="inputConservative" type="text" />

	<label># of Experitse Dice</label> 
	<input id="inputExpertise" type="text" />				

	<label># of Misfortune Dice</label> 
	<input id="inputMisfortune" type="text" />	

	<label># of Challenge Dice</label> 
	<input id="inputChallenge" type="text" />		

     <input type="button" onclick="redraw();" value="Go" style="display:block;" />
</div>
<div id="hammers_chart_div"></div>
<div id="exactly_chart_div"></div>
<div id="atleast_chart_div"></div>
<div id="log">
</div>
<body>
<div>
</div>

<script>
google.load("visualization", "1", {packages:["corechart"]});



var dieHash = {
		Template:{
					success_1:[0,0],
					success_2:[0,0],
					success_1_boon_1:[0,0],
					success_1_exert_1:[0,0],
					success_1_delay_1:[0,0],
					righteous_success_1:[0,0],
					sigmars_comet_1:[0,0],
					boon_1:[0,0],
					boon_2:[0,0],
					challenge_1:[0,0],
					challenge_2:[0,0],
					bane_1:[0,0],
					bane_2:[0,0],
					chaos_star_1:[0,0],
					nothing:[0,0]				
		},
		Expertise:{
					success_1:[1,6],
					success_2:[0,0],
					success_1_boon_1:[0,0],
					success_1_exert_1:[0,0],
					success_1_delay_1:[0,0],
					righteous_success_1:[1,6],
					sigmars_comet_1:[1,6],
					boon_1:[2,6],
					boon_2:[0,0],
					challenge_1:[0,0],
					challenge_2:[0,0],
					bane_1:[0,0],
					bane_2:[0,0],
					chaos_star_1:[0,0],
					nothing:[1,6]					
		},		
		Reckless:{
					success_1:[0,10],
					success_2:[2,10],
					success_1_boon_1:[1,10],
					success_1_exert_1:[2,10],
					success_1_delay_1:[0,0],
					righteous_success_1:[0,0],
					sigmars_comet_1:[0,0],
					boon_1:[0,0],
					boon_2:[1,10],
					challenge_1:[0,0],
					challenge_2:[0,0],
					bane_1:[2,10],
					bane_2:[0,0],
					chaos_star_1:[0,0],
					nothing:[2,10]					
		},			
		Conservative:{
					success_1:[4,10],
					success_2:[0,0],
					success_1_boon_1:[1,10],
					success_1_exert_1:[0,0],
					success_1_delay_1:[2,10],
					righteous_success_1:[0,0],
					sigmars_comet_1:[0,0],
					boon_1:[2,10],
					boon_2:[0,0],
					challenge_1:[0,0],
					challenge_2:[0,0],
					bane_1:[0,0],
					bane_2:[0,0],
					chaos_star_1:[0,0],
					nothing:[1,10]					
		},		
		Characteristic:{
					success_1:[4,8],
					success_2:[0,0],
					success_1_boon_1:[0,0],
					success_1_exert_1:[0,0],
					success_1_delay_1:[0,0],
					righteous_success_1:[0,0],
					sigmars_comet_1:[0,0],
					boon_1:[2,8],
					boon_2:[0,0],
					challenge_1:[0,0],
					challenge_2:[0,0],
					bane_1:[0,0],
					bane_2:[0,0],
					chaos_star_1:[0,0],
					nothing:[2,8]					
		},		
		Fortune:{
					success_1:[2,6],
					success_2:[0,6],
					success_1_boon_1:[0,6],
					success_1_exert_1:[0,6],
					success_1_delay_1:[0,6],
					righteous_success_1:[0,6],
					sigmars_comet_1:[0,6],
					boon_1:[1,6],
					boon_2:[0,6],
					challenge_1:[0,6],
					challenge_2:[0,6],
					bane_1:[0,6],
					bane_2:[0,6],
					chaos_star_1:[0,6],
					nothing:[3,6]},
		Misfortune:{
					success_1:[0,6],
					success_2:[0,6],
					success_1_boon_1:[0,6],
					success_1_exert_1:[0,6],
					success_1_delay_1:[0,6],
					righteous_success_1:[0,6],
					sigmars_comet_1:[0,6],
					boon_1:[0,6],
					boon_2:[0,6],
					challenge_1:[2,6],
					challenge_2:[0,6],
					bane_1:[1,6],
					bane_2:[0,6],
					chaos_star_1:[0,6],
					nothing:[3,6]},
		Challenge:{
					success_1:[0,0],
					success_2:[0,0],
					success_1_boon_1:[0,0],
					success_1_exert_1:[0,0],
					success_1_delay_1:[0,0],
					righteous_success_1:[0,0],
					sigmars_comet_1:[0,0],
					boon_1:[0,0],
					boon_2:[0,0],
					challenge_1:[2,8],
					challenge_2:[2,8],
					bane_1:[1,8],
					bane_2:[1,8],
					chaos_star_1:[1,8],
					nothing:[1,8]					
		}					
	};


/*
* Counts the possible hammers on a die. Does not figure in righteous success reroll here.
*/ 
function totalPossibleSuccessesByDie(die) {
	var success = 0;
	if (dieHash[die].righteous_success_1[0] > 0) {success = 1;}
	if (dieHash[die].success_1[0] > 0) {success = 1;}
	if (dieHash[die].success_1_boon_1[0] > 0) {success = 1;}
	if (dieHash[die].success_1_delay_1[0] > 0) {success = 1;}
	if (dieHash[die].success_1_exert_1[0] > 0) {success = 1;}
	if (dieHash[die].success_2[0] > 0) {success = 2}
	return success;
}

/*
* Returns a ratio for the chance of rolling a success side (NOT # of hammers). Does not figure in righteous success reroll here.
*/ 
function successRatioByDie(die) {
	var success = 0.0;

	if (dieHash[die].righteous_success_1[0] > 0) {		
		success = success + (dieHash[die].righteous_success_1[0]/dieHash[die].righteous_success_1[1]);		
	}

	if (dieHash[die].sigmars_comet_1[0] > 0) {		
		success = success + (dieHash[die].sigmars_comet_1[0]/dieHash[die].sigmars_comet_1[1]);
	}	

	if (dieHash[die].success_1[0] > 0) {		
		success = success + (dieHash[die].success_1[0]/dieHash[die].success_1[1]);
	}

	if (dieHash[die].success_2[0] > 0) {
		success = success + (dieHash[die].success_2[0]/dieHash[die].success_2[1]);
	}

	if (dieHash[die].success_1_boon_1[0] > 0) {		
		success = success + (dieHash[die].success_1_boon_1[0]/dieHash[die].success_1_boon_1[1]);
	}

	if (dieHash[die].success_1_delay_1[0] > 0) {
		success = success + (dieHash[die].success_1_delay_1[0]/dieHash[die].success_1_delay_1[1]);		
	}	

	if (dieHash[die].success_1_exert_1[0] > 0) {		
		if (dieHash[die].success_1_exert_1[0] > 0) {
			success = success + (dieHash[die].success_1_exert_1[0]/dieHash[die].success_1_exert_1[1]);		
		}
	}	
	
	return success;
}

function challengeRatioByDie(die) {
	var challenge = 0;
	/*
	if (dieHash[die].1_chaos_star[0] > 0) {challenge = 1;}
	if (dieHash[die].1_challenge[0] > 0) {challenge = 1;}
	if (dieHash[die].2_challenge[0] > 0) {challenge = 2;}
	*/
	return challenge;
}

/**math **/

/* factorial. */
function productRange(a,b) {
  var product=a,i=a;
  while (i++<b) {
    product*=i;
  }
  return product;
}

function combinations(n,k) {
  if (k == 0) return(1);
  if (n==k) {
    return 1;
  } else {
    k=Math.max(k,n-k);
    return productRange(k+1,n)/productRange(1,n-k);
  }
}

function permutations(n,k) {
  return productRange(k+1,n);
}

/*
 * Exactly k successes in n trials = nCk * p^k * q^(n-k)
 * n = # of trials
 * k = # of successes
 * p = prob of success (q= prob of failure or 1-p)
*/
function probability(n,k,p) {
	//1-p is the probability of failure
	return combinations(n,k) * Math.pow(p,k) * Math.pow((1-p),(n-k));
}

function factorial(n) {
	if (n <= 1) return(1); else return n*factorial(n-1);
} // factorial

/* Prob of between k1 and k2 successes
 * k1 <= X <= k2 
*/
function distribution(n,p,k1,k2) {
	var sum = 0;
	for (var k = k1; k <= k2; k++) {
		sum += probability(n,k,p);
	}
	return sum;;
}

/*
 * Returns the GCD of the given integers. Each input must be non-negative.
 */
function gcd(x, y) {
	while (y != 0) {
		var z = x % y;
		x = y;
		y = z;
	}
	return x;
}
/** end math */



/*
* Adds 0's to the end of an array to the given length (inclusive). Used for matching data sets in charts so they align (2 dice vs 3 dice, etc)
*/
function padArrayWithZeros( arr, length) {
	if (arr.length < length) {
		var difference = length - arr.length;
		for (var i = 0; i < difference; i++) {
			arr.push(0);
		}
	}
	return arr;
} 



function calculateHammerToSuccessSideAvg(){
		
	var avgHammersPerSuccessSide = (fortuneDieCount + conservativeDieCount + characteristicDieCount + (1.4*recklessDieCount) + ((1+((1/6)*(1/2)))*expertiseDieCount))/(fortuneDieCount+characteristicDieCount+expertiseDieCount+recklessDieCount+conservativeDieCount);
	// 1.4 // reckless
	// 1+((1/6)*(1/2)) // expertise
	return avgHammersPerSuccessSide;
}

function clenseInput(){
	
	fortuneDieCount = parseInt($('#inputFortune').val());
	if (!fortuneDieCount) {
		fortuneDieCount = 0;
	}

	characteristicDieCount = parseInt($('#inputCharacteristic').val());
	if (!characteristicDieCount) {
		characteristicDieCount = 0;
	}

	expertiseDieCount = parseInt($('#inputExpertise').val());
	if (!expertiseDieCount) {
		expertiseDieCount = 0;
	}

	recklessDieCount = parseInt($('#inputReckless').val());
	if (!recklessDieCount) {
		recklessDieCount = 0;
	}		

	conservativeDieCount = parseInt($('#inputConservative').val());
	if (!conservativeDieCount) {
		conservativeDieCount = 0;
	}

	misfortuneDieCount = parseInt($('#inputMisfortune').val());
	if (!misfortuneDieCount) {
		misfortuneDieCount = 0;
	}

	challengeDieCount = parseInt($('#inputChallenge').val());
	if (!challengeDieCount) {
		challengeDieCount = 0;
	}		
}


/* 
* Builds the array of data for the # of succees sides on a given die.
* Exits if no success sides are possible
*/
function redrawExactlyNSucessesChart() {
	var chartData = [["Success Sides == N","Fortune","Characteristic","Expertise","Reckless","Conservative","Combined"]];
	var fortuneData = [];
	var characteristicData = [];
	var expertiseData = [];
	var recklessData = [];
	var conservativeData = [];

	

	if (fortuneDieCount > 0) {
		fortuneData = calculateExactly1ToQtySucesses("Fortune", fortuneDieCount, successRatioByDie("Fortune"));
	}
	if (characteristicDieCount > 0) {
		characteristicData = calculateExactly1ToQtySucesses("Characteristic", characteristicDieCount, successRatioByDie("Characteristic"));
	}

	if (expertiseDieCount > 0) {
		expertiseData = calculateExactly1ToQtySucesses("Expertise", expertiseDieCount, successRatioByDie("Expertise"));
	}

	if (recklessDieCount > 0) {
		recklessData = calculateExactly1ToQtySucesses("Reckless", recklessDieCount, successRatioByDie("Reckless"));
	}		

	if (conservativeDieCount > 0) {
		conservativeData = calculateExactly1ToQtySucesses("Conservative", conservativeDieCount, successRatioByDie("Conservative"));
	}


	var goodDicePool = (fortuneDieCount+characteristicDieCount+expertiseDieCount+recklessDieCount+conservativeDieCount);
	if (goodDicePool <= 0) {
		// no data to draw a chart with.
		return;
	}

	var megaRatio = ((fortuneDieCount*successRatioByDie("Fortune"))+(characteristicDieCount*successRatioByDie("Characteristic"))+(expertiseDieCount*successRatioByDie("Expertise"))+(recklessDieCount*successRatioByDie("Reckless"))+conservativeDieCount*successRatioByDie("Conservative"))/goodDicePool;
	var combinedData = calculateExactly1ToQtySucesses("Combined",goodDicePool,megaRatio);

	fortuneData = padArrayWithZeros(fortuneData, goodDicePool);
	characteristicData = padArrayWithZeros(characteristicData, goodDicePool);
	expertiseData = padArrayWithZeros(expertiseData, goodDicePool);
	recklessData = padArrayWithZeros(recklessData, goodDicePool);
	conservativeData = padArrayWithZeros(conservativeData, goodDicePool);

	/* turn the matrix on its side to fit the charting tool */
	for (var i = 0; i < goodDicePool; i++) {
		chartData.push([(i+1) + "", fortuneData[i], characteristicData[i], expertiseData[i], recklessData[i], conservativeData[i], combinedData[i]]);
	}

	drawExactlyNSucessesChart(chartData);
	return combinedData;
}


function redrawAtLeastNSuccessChart() {

	var chartData = [["Success Sides >= N","Fortune","Characteristic","Expertise","Reckless","Conservative","Combined"]];
	var fortuneData = [];
	var characteristicData = [];
	var expertiseData = [];
	var recklessData = [];
	var conservativeData = [];

	if (fortuneDieCount > 0) {
		fortuneData = calculateAtLeast1ToQtySucesses("Fortune", fortuneDieCount, successRatioByDie("Fortune"));
	}

	if (characteristicDieCount > 0) {
		characteristicData = calculateAtLeast1ToQtySucesses("Characteristic", characteristicDieCount, successRatioByDie("Characteristic"));
	}

	if (expertiseDieCount > 0) {
		expertiseData = calculateAtLeast1ToQtySucesses("Expertise", expertiseDieCount, successRatioByDie("Expertise"));
	}

	if (recklessDieCount > 0) {
		recklessData = calculateAtLeast1ToQtySucesses("Reckless", recklessDieCount, successRatioByDie("Reckless"));
	}		

	if (conservativeDieCount > 0) {
		conservativeData = calculateAtLeast1ToQtySucesses("Conservative", conservativeDieCount, successRatioByDie("Conservative"));
	}

	var goodDicePool = (fortuneDieCount+characteristicDieCount+expertiseDieCount+recklessDieCount+conservativeDieCount);
	if (goodDicePool <= 0) {
		// no data to draw a chart with.
		return;
	}

	var megaRatio = ((fortuneDieCount*successRatioByDie("Fortune"))+(characteristicDieCount*successRatioByDie("Characteristic"))+(expertiseDieCount*successRatioByDie("Expertise"))+(recklessDieCount*successRatioByDie("Reckless"))+conservativeDieCount*successRatioByDie("Conservative"))/goodDicePool;
	var combinedData = calculateAtLeast1ToQtySucesses("Combined",goodDicePool,megaRatio);

	fortuneData = padArrayWithZeros(fortuneData, goodDicePool);
	characteristicData = padArrayWithZeros(characteristicData, goodDicePool);
	expertiseData = padArrayWithZeros(expertiseData, goodDicePool);
	recklessData = padArrayWithZeros(recklessData, goodDicePool);
	conservativeData = padArrayWithZeros(conservativeData, goodDicePool);

	/* turn the matrix on its side to fit the charting tool */
	for (var i = 0; i < goodDicePool; i++) {
		chartData.push([(i+1) + "", fortuneData[i], characteristicData[i], expertiseData[i], recklessData[i], conservativeData[i], combinedData[i]]);
	}

	drawAtLeastNSucessesChart(chartData);
	return combinedData;
}

function drawExactlyNSucessesChart(data_) {
	var data = google.visualization.arrayToDataTable(data_);

	var options = {
	  title: '% Chance of Exactly N Sucess Sides',
	  vAxis: {title: "% Chance"},
      hAxis: {title: "Success Sides"},
	  colors: ['grey', 'blue', 'gold', 'red', 'green', 'brown'],
	  seriesType: "bars",
	  series: {5: {type: "line"}},
	  height: 400
	};

	var chart = new google.visualization.ComboChart(document.getElementById('exactly_chart_div'));
	chart.draw(data, options);
}

function drawAtLeastNSucessesChart(data_) {
	var data = google.visualization.arrayToDataTable(data_);

	var options = {
	  title: '% Chance of At Least X Success Sides By Die',
	  colors: ['grey', 'blue', 'gold', 'red', 'green', 'brown'],
	  vAxis: {title: "% Chance"},
      hAxis: {title: "Success Sides"},
	  seriesType: "bars",
	  series: {5: {type: "line"}},
	  height: 400
	};

	var chart = new google.visualization.ComboChart(document.getElementById('atleast_chart_div'));
	chart.draw(data, options);
}

function drawHammersChart(data_) {
	var data = google.visualization.arrayToDataTable(data_);

	var options = {
	  title: 'Hammers to Success Sides for Dice Pool',
	  colors: ['green','red','black','purple'],
	  vAxis: {title: "Avg # of Hammers"},
      hAxis: {title: "# of Success Sides"},
	  height: 400
	};

	var chart = new google.visualization.LineChart(document.getElementById('hammers_chart_div'));
	chart.draw(data, options);
}

/*
 * Given a die and a qty, return an array of chances for at least n sucesses for 1..qty.
 * If a ratio is passed, use that in place of the die's ratio. 
 */
function calculateAtLeast1ToQtySucesses(dieName, qty, ratio) {
	var cumulativeChanceForCompleteSuccess = 1;
	var totalPossibleHammersForSet = 0;
	var returnDataAtLeastNSucesses = []; // an array of 4 precision %'s for each at least 1..qty successes

	log = log + dieName + " die chance for (1) success is " + (100*ratio).toPrecision(4) + "%.<br/>";

	// compute chance for nothing. basiclly doing this twice, as the last between 1 and n successes is the same thing
	var chanceForNoSucess = 0;
	for(var x=0; x < qty; x++) {
		if (chanceForNoSucess==0) {
			chanceForNoSucess=(1-ratio);
		} else {
			chanceForNoSucess=chanceForNoSucess * (1-ratio);
		}
	}
	// the chance for at least something is 1 - the chance for nothing
	var theChanceForSomething = 1-chanceForNoSucess;
	returnDataAtLeastNSucesses.push(parseFloat((theChanceForSomething*100).toPrecision(4)));
	log = log + " + At least 1 successes of " + qty + " = " + (theChanceForSomething*100).toPrecision(4) + "%.<br/>";

	for(var dieIndex = 1; dieIndex <= qty; dieIndex++) {
		var dieIndexOrLessOfQty =  distribution(qty, ratio, 0,dieIndex);
		var betweenOneAndDieIndexOfQty =  distribution(qty, ratio, 1,dieIndex);
		log = log + " + Between 1 and " + dieIndex + " successes of " + qty + " = " + (betweenOneAndDieIndexOfQty*100).toPrecision(4) + "%.<br/>";
		cumulativeChanceForCompleteSuccess = cumulativeChanceForCompleteSuccess * ratio;
		log = log + " + Chance of exactly " + dieIndex + " out of " + dieIndex + " successes = " + (cumulativeChanceForCompleteSuccess*100).toPrecision(4) + "%.<br>"; 

		if (dieIndex < qty) {
			var atLeastDieIndexPlusOne = 1 - dieIndexOrLessOfQty;
			log = log + " + At least " + (dieIndex + 1) + " successes = " + (atLeastDieIndexPlusOne*100).toPrecision(4) + "%.<br/>";
			returnDataAtLeastNSucesses.push(parseFloat((atLeastDieIndexPlusOne*100).toPrecision(4)));
		}
	}	

	$('#log').html(log);
	return returnDataAtLeastNSucesses;
}

/*
* combinedExactlyData = array of 1 .. length sides (index), and their % chance of occurance
*/
function redrawHammerChart(maxSuccessSides) {

	var chartData=[["Success Sides","Avg Hammers", "Max Hammers"]];
	var maxHammers = (recklessDieCount + expertiseDieCount) * 2 + fortuneDieCount + characteristicDieCount + conservativeDieCount;
	var maxHammerDie = 1;
	if ((recklessDieCount>0 || expertiseDieCount>0)) {
		maxHammerDie = 2;
	}

	var hammerRatio=calculateHammerToSuccessSideAvg(); 
	for (var side=1; side<=maxSuccessSides; side++) {
		chartData.push([side, (side*hammerRatio), (side*maxHammerDie)]);
	}

	var data = google.visualization.arrayToDataTable(chartData);

	var options = {
	  title: 'Hammers to Success Sides for Dice Pool',
	  colors: ['green','red','black','purple'],
	  vAxis: {title: "Avg # of Hammers"},
      hAxis: {title: "# of Success Sides"},
	  height: 400
	};

	var chart = new google.visualization.LineChart(document.getElementById('hammers_chart_div'));
	chart.draw(data, options);
}


function calculateExactly1ToQtySucesses(dieName, qty, ratio) {
	var returnDataExactlyNSucesses = []; // an array of 4 precision %'s for each at least 1..qty successes
	for(var dieIndex = 1; dieIndex <= qty; dieIndex++) {
		returnDataExactlyNSucesses.push(parseFloat((probability(qty,dieIndex,ratio)*100).toPrecision(4)));
	}	
	return returnDataExactlyNSucesses;
}

function getGoodDicePoolCount() {
	return (fortuneDieCount+characteristicDieCount+expertiseDieCount+recklessDieCount+conservativeDieCount);
}

/*
* Resets the log and redraws the charts based on the data in the form.
*/
function redraw() {
	var log = "";
	var fortuneDieCount = 0;
	var expertiseDieCount = 0;
	var recklessDieCount = 0;
	var conservativeDieCount = 0;
	var challengeDieCount = 0;
	var characteristicDieCount = 0;
	var misfortuneDieCount = 0;

	$('#log').html("");
	log = "";
	clenseInput();
	var combinedAtLeastData = redrawAtLeastNSuccessChart();
	var combinedExactlyData = redrawExactlyNSucessesChart();
	
	redrawHammerChart(getGoodDicePoolCount());
}
</script>
</body>
</html>